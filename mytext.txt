    [Haskell zip and zipWith]
    :zip::[a]->[b]->[(a,b)]
    `[
        zip [1..3] [1..3]  = [(1,1)(2,2)(3,3)] 
    `]

    [Haskell zip]
    `[
        zip [1, 2] [3, 4]
        -- output [(1, 3), (2, 4)]
    `]

    [Haskell zipWith]
    `[
        zipWith [1, 2] [3, 4]
        -- output [(1, 3), (2, 4)]
    `]

    [Haskell zipWith]
    :zipWith::(a->b->c)->[a]->[b]->[c]
    `[
        let list1 = [1..4] 
        let list2 = [10..20] 
        zipWith (\x y -> x+y) list1 list2 
    `]

    [Haskell uncurry and mapM_]
    :zipWith::(a->b->c)->[a]->[b]->[c]
    `[
        let list1 = ["/file1.txt", "/fil2.txt"]
        let list2 = ["/tmp/name1.txt", "/tmp/name2.txt"]
        mapM_ (uncurry copyFile) $ zip list1 list2 
    `]

    [Haskell curry]
    :curry::(a,b)->c->a->b->c
    convert uncurried function to curried function 
    `[
        let c = \(x, y)-> x + y
        curry c 1 2   -- output 3 
    `]

    [Haskell uncurry]
    :uncurry::a->b->c->(a,b)->c
    convert curried function to uncurried function
    `[
        mapM_(uncurry copyFile) $ zip list1 list2 
        let un = \x y -> x*y
        uncurry un (2, 3)   -- output 6
    `]

    [Haskell subRegex]
    :subRegex::Regex->input->replacement->output
    `[
        subRegex(mkRegex "/dog/") "the dog" "cat\0"
        -- output "that catdog"
    `]

    [Haskell merge two lists]
    `[
        mergeList::[String]->[String]->[String]
        mergeList [] [] = []
        mergeList  l  [] = l 
        mergeList []  r = r 
        mergeList (x:xs) (y:ys) = x:y:mergeList xs ys
    `]

    [Haskell merge two sorted lists]
    `[
        mergeSortList::[Int]->[Int]->[Int]
        mergeSortList [] r          = r
        mergeSortList l []          = l
        mergeSortList (x:xs) (y:ys) = if x < y then x:(mergeSortList xs (y:ys)) else y:(mergeSortList (x:xs) ys)
    `]

    [Haskell merge two lists with Maybe]
    `[
        mergeList2::[a]->[a]->Maybe [a]
        mergeList2 [] [] = Just [] 
        mergeList2 (x:xs) (y:ys) = 
                    case mergeList2 xs ys of
                    Just merged -> Just (x:y:merged)
                    Nothing  -> Nothing
        mergeList2 _ _  = Nothing
    `]

    [Haskell Quick Sort]
    `[
        quickSort::[Int]->[Int]
        quickSort [] = []
        quickSort [x] = [x]
        quickSort l = quickSort(left) ++ p:[] ++ quickSort right 
                            where
                                left =  [x | x <- init l, x < p]
                                right = [x | x <- init l, x >= p]
                                p = last l 
    `]

    [Haskell Merge Sort]
    `[
        mergeSort::[Int]->[Int]
        mergeSort [] = []
        mergeSort [x] = [x]
        mergeSort l = merge(mergeSort left) (mergeSort right) 
                        where
                            half = (length l) `div` 2
                            left = take half l
                            right = drop half l  

                            merge::[Int]->[Int]->[Int]
                            merge [] r = r
                            merge l [] = l
                            merge (x:xs) (y:ys)  = if x < y
                                                    then 
                                                       x:merge xs (y:ys) 
                                                    else
                                                       y:merge (x:xs) ys 
    `]


    [Haskell split]
    `[
        split::[Int]->([Int], [Int])
        split [] = ([], []) 
        split [x] = ([x], [])
        split (x:y:rest) = (x:xs, y:xy)   
                        where
                            (xs, xy) = split rest
        -- split [1,2,3]  = ([1,3], [2])
        -- split [1,2,3,4]  = ([1,3], [2,4])
    `]
    [Haskell check array]
    `[
        check sum(x_0, x_1,...,x_k) == sum(x_k+1,...,x_n)

        checkSum::[Int]->Int->Bool
        checkSum []  _ = True
        checkSum [x] _ = x    =  = 0
        checkSum l inx | sum(take inx l) == sum(drop inx l) = True
                       | inx <= length l = checkSum l (inx+1)
                       | otherwise       = False

    `]

    [Haskell check array 2]
    `[
        -- check sum(x_0, x_1,...,x_k) == sum(x_k+1,...,x_n)

        -- import Data.List(inits, tails)
        checkSum2::[Int]->Bool
        checkSum2 xs | len > 0 = True 
                    | otherwise = False
                    where
                        len = length $ filter(\x-> sum (fst x) == sum (snd x)) $ splits xs
                        splits::[a] -> [([a], [a])]
                        splits xs = zip (inits xs) (tails xs) 

    `]

    [Haskell check array 3]
    `[
        -- check sum(x_0, x_1,...,x_k) == sum(x_k+1,...,x_n)

        checkSum4::[Int] -> Bool
        checkSum4 a = go a 0 (sum a)
           where go [] left right = left==right
                 go (x:xs) left right | left==right = True
                                      | otherwise = go xs (left+x) (right-x)
    `]

    [Haskell Matrix Multiplication]
    `[
        m1 = [[1, 2], 
              [3, 4]
             ]
        m2 = [[5, 7], 
              [8, 9]
             ]

        mmult::[[Int]] -> [[Int]] -> [[Int]] 
        mmult a b = [ [ sum $ zipWith (*) ar bc | bc <- (transpose b) ] | ar <- a ]
    `]
 

    [vim command]
    :/\(if\)\ze\(then\)         // if follows then "[if]then"
    :/\(if\)\zs\(then\)         // then starts with if "if[then]" 
    [Vim Script get background color]
    `[
         :echo synIDattr(synIDtrans(hlID("Normal")), "bg") [:h hlID]       
    `]

    [Linux command]
    git branch shows on command prompt
    `[
        parse_git_branch(){
            git branch 2> /dev/null | sed -e 's/* \(.*\)/ \(\1)/'
        }
        export PS1="\u$(parse_git_branch)\w$"
        \u - Username
        \w - Full path
        \h - Host name
    `]

    [[ src=image/manhattan.png w=50% h=50%]]

     

